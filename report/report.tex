\documentclass[12pt, a4paper]{article}
    
\usepackage{homework}
\usepackage{amsmath}				% For Math
\usepackage{fancyhdr}				% For fancy header/footer
\usepackage{graphicx}				% For including figure/image
\usepackage{cancel}					% To use the slash to cancel out stuff in work
\usepackage{multirow}
\usepackage{lastpage}

\usepackage[firstpage=true]{background}
\backgroundsetup{
    scale=0.3,
    angle=0,
    opacity=0.1,
    contents={%
        \includegraphics[scale=1]{figs/Emblem_of_CU.png}
    }
}

%%%%%%%%%%%%%%%%%%%%%%
% Set up fancy header/footer
\pagestyle{fancy}
\setlength{\headheight}{28pt}
\fancyhead[LO,L]{CENG2400 Embedded System Design\\Author: C.H. Yu, Y.H. Tam, C.W. Leung}
\fancyhead[CO,C]{}
\fancyhead[RO,R]{Final Project\\Date: \today}
\fancyfoot[LO,L]{}
\fancyfoot[CO,C]{}
\fancyfoot[RO,R]{Page \thepage\ of \pageref{LastPage}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
    \begin{center}

		\bf\LARGE{The Chinese University of Hong Kong}
        \bf\Large{Department of Computer Science\\and Engineering}
		
		\vspace{80pt}
		
		\vspace{15pt}
		\textbf{\Large CENG2400 Embedded System Design\\}
		\vspace{6pt}
		\textbf{\Large Final Project - Laser Turret}\\
		\vspace{6pt}
		\textbf{\Large Report}\\
        \vspace{6pt}
        {\large Project Demo Date: 13 Dec 2024}\\
        {\large Project Report Deadline: 20 Dec 2024 23:59}
		\vspace{40pt}
		
        \vspace{15pt}
		\textbf{\normalsize
            1155193237 - Yu Ching Hei (chyu2@cse.cuhk.edu.hk)\\
			1155223226 - Tam Yiu Hei (1155223226@link.cuhk.edu.hk)\\
			1155194650 - Leung Chung Wang (1155194650@link.cuhk.edu.hk)\\}
		\vspace{40pt}
        \textbf{\large Source code and project history is available on GitHub:}\\
        \normalsize \url{https://github.com/Jellyfish227/CENG2400_Embedded_System_Design.git}\\
        \vspace{60pt}
		\textit{Under the kind guidance of}\\
		\textbf{\large Prof. Ming-Chang YANG}\\
		\vspace{20pt}
        \textit{Also thank you for the help provided by teaching assistants}\\
		\textbf{\large 
        Mr. Chenchen ZHAO\\
        Mr. Kezhi LI\\
        Mr. Han ZHAO\\
        Mr. Zhirui ZHANG\\
        }
		
	\end{center}
\end{titlepage}
\setcounter{page}{2}
\tableofcontents
\section{Introduction}
The CENG2400 final project involved implementing a gyroscope-controlled laser turret 
that uses the MPU6050 to direct the laser. Our goal was to create a responsive turret for maximizing hits.

\noindent The workflow consists of two phases:
\begin{enumerate}
    \item \textbf{Master End:} We collect and process gyro and accelerometer 
          data from the \\MPU6050, then transmit the calculated angles via UART.
    \item \textbf{Slave End:} The angles are received and converted into PWM 
          signals to control the servo motors.
\end{enumerate}
This report outlines our challenges faced and insights gained during implementation, aiming to deliver a functional motion-controlled laser turret.

\section{Division of Work}
\begin{tabularx}{\textwidth}{|l||X|}
    \hline
    \textbf{Task} & \textbf{Person In Charge} \\
    \hline\hline
    \textbf{Master End} & \textbf{Yu Ching Hei, Tam Yiu Hei, Leung Chung Wang} \\
    \hline
    \textbf{Slave End} & \textbf{Yu Ching Hei, Tam Yiu Hei} \\
    \hline
    \textbf{Report} & \textbf{Yu Ching Hei, Tam Yiu Hei, Leung Chung Wang} \\
    \hline
\end{tabularx}

\section{Chanllenges during implementation}
\subsection{Transmission of Data}
\subsubsection{Master end: First edition of data transmission formatting}\text{}
\begin{code}
/* Commit hash: c6e8ed6, main_mpu.c*/
void sendData(float yawAngle, float pitchAngle) {
    char data[22];
    // format the data as a string
    sprintf(data, "%.10f,%.10f", yawAngle, pitchAngle);
    char* chp = data;
    while (*chp) 
        UARTCharPut(UART5_BASE, *chp++);
}
\end{code}\text{}\\
In this initial implementation, we formatted the yaw and pitch angles into a string using sprintf. 
While this allowed us to send the angles with high precision (10 decimal places), 
the long string to be sent over UART wirelessly increases the risk of data loss. And turns out during the testing, 
we found that the data received was very unstable, we have presumed that the problem is due to the data being sent is too long, 
which means there are more characters that can potentially be lost, and just one character lost can cause the whole data to be corrupted.

\subsubsection{Master end: Second edition of data transmission formatting}\text{}
\begin{code}
/* Commit hash: af09000, main_mpu.c */
void sendData(float yawAngle, float pitchAngle) {
    char data[7]; 
    sprintf(data, "%03d%03d\0", (int)yawAngle, (int)pitchAngle);
    /* same send looping as before*/
    UARTCharPut(UART5_BASE, '\n'); // '\n' to mark end of transmission
}
\end{code}
\textbf{}\\
In this update, we have made 2 important changes:
\begin{enumerate}
    \item We have changed the data string to be a string of 7 characters, which is a lot shorter than the previous 22 characters.
    \item We have added a newline character to indicate the end of the transmission, which is a simple way to check the data integrity.
\end{enumerate}
We decided to sacrifice the precision of the data to just send the integral part of the angle, 
in order to reduce the risk of data corruption due to data loss during transmission. 
And in the previous implementation, we found that we have no way to check the data integrity, 
so we have to add a newline character to indicate the end of the transmission.
However, the problem was not fixed, in the slave end, we found that the data received was still very unstable, 
we noticed that sometimes the data received would swap their positions(i.e. the yaw angle would be the pitch angle and vice versa), 
or sometimes some digits that should be in the pitch angle would appears in the array of yaw angle characters received.
Therefore, we started to investigate in the slave end.

\subsubsection{Slave end: wrongly assumed the problem is during data unpacking}\text{}
\begin{code}
/* Commit hash: 7f6934b, main_servo.c */
void UART5IntHandler(void) {
    uint32_t ui32Status = UARTIntStatus(UART5_BASE, true);
    UARTIntClear(UART5_BASE, ui32Status);
    uint32_t charCount = 0;
    while (UARTCharsAvail(UART5_BASE)) {
        char b = UARTCharGet(UART5_BASE);
        if (charCount < 3) {
            charYaw[charCount] = b;
        } else if (charCount < 6) {
            charPitch[charCount - 3] = b;
        }
        charCount++;
    }
}
\end{code}\text{}\\
In the original version of slave end code, we used an interrupt to receive data from the UART. 
We just called the interrupt handler to put the received character into two separate arrays. 
And we traslate the character array into integer in the main loop by calling atoi().
When we are testing the code in debug mode, we found that the integral data was wrong, 
so we assumed it is the problem to translate it separately in other loop, so we moved the 
\begin{verbatim}
    degreeArr[0] = atoi(charYaw);
    degreeArr[1] = atoi(charPitch);
\end{verbatim}
into the interrupt handler, and we found that the integral data was still incorrect, 
which means that the wrong data was not due to the conversion process but the character receiving process instead.

\subsubsection{Slave end: investigating receive logic by locking or raising flags}\text{}
\begin{code}
/* Commit hash: , main_servo.c */
void UART5IntHandler(void) {
    uint32_t ui32Status = UARTIntStatus(UART5_BASE, true);
    UARTIntClear(UART5_BASE, ui32Status);
    isFinished = 0; // Reset flag

    uint32_t charCount = 0;
    if (processLock) {
        char b = UARTCharGet(UART5_BASE);
        charCount++;
    }
    isFinished = 1;
    processLock = 0; // Release lock
}
\end{code}\text{}\\
In this attempt, we introduced a locking mechanism to handle data reception more effectively. 
This approach aimed to prevent data loss by ensuring that the system only processed one set of data 
at a time. However, we still faced issues with data integrity, especially when the UART buffer was 
filled with new incoming data before the previous data was fully processed.

\subsubsection{Slave end: use polling to receive data instead of interrupt}\text{}
\begin{code}
/* Commit hash: , main_mpu.c */ //FIXME: wrong code included
void sendData(int yawAngle, int pitchAngle) {
    char data[8]; // Increased buffer size for safety
    while (!UARTSpaceAvail(UART5_BASE)) {}
    snprintf(data, sizeof(data), "%03.0f,%03.0f", roundf(yawAngle), roundf(pitchAngle));
    char *chp = data;
    while (*chp) {
        UARTCharPut(UART5_BASE, *chp++);
    }
    UARTCharPut(UART5_BASE, '/'); // End of data
}
\end{code}\text{}\\
We decided to use a polling mechanism instead of relying on interrupts to avoid data integrity issues. 
By sending the yaw and pitch angles as ASCII characters followed by a delimiter (/), 
we aimed to ensure that each data packet was correctly terminated. 
However, ensuring that no data was lost during transmission remained a challenge.

\subsubsection{Slave end: data integrity checking}\text{}
\begin{code}
/* Commit hash: , main_servo.c */
while (true) {
    while (UARTCharsAvail(UART5_BASE)) {
        char b = UARTCharGet(UART5_BASE);
        degreeArr[isPitch] = b;
        isPitch = !isPitch;
        idx++;
        if (b == '/' && idx % 3 != 0) {
            // Logic to ensure data is valid
        }
    }
}
\end{code}\text{}\\
In this code, we implemented checks to verify the integrity of received data. 
We ensured that only complete and correctly formatted data packets were processed by checking for start and end indicators. 
However, we still faced challenges in ensuring that the data received from the MPU6050 sensor was not corrupted by noise, 
often leading to missed or incorrect angle readings.

\subsubsection{Final adjustment}\text{}
\begin{code}
/* Commit hash: , main_mpu.c */
char const START_INDICATOR = 254;
char const END_INDICATOR = 255;
void sendData(int yawAngle, int pitchAngle) {
    while (!UARTSpaceAvail(UART5_BASE)) {}
    UARTCharPut(UART5_BASE, START_INDICATOR);
    UARTCharPut(UART5_BASE, (yawAngle >> 8) & 0xFF);
    UARTCharPut(UART5_BASE, yawAngle & 0xFF);
    UARTCharPut(UART5_BASE, (pitchAngle >> 8) & 0xFF);
    UARTCharPut(UART5_BASE, pitchAngle & 0xFF);
    while (!UARTSpaceAvail(UART5_BASE)) {
        UARTCharPut(UART5_BASE, END_INDICATOR);
    }
}
\end{code}\text{}\\
In the final adjustments, we emphasized starting and ending indicators for each data transmission. 
By sending the yaw and pitch angles as separate bytes, we improved the clarity of the data being transmitted. 
This method aimed to reduce confusion and ensure that the receiving end could accurately reconstruct the angles. 
Through this iterative process, we learned the importance of robust error handling and effective communication strategies in embedded systems.

\subsection{MPU Connection}
\text{}\\
In our project, we faced challenges due to noise interference in receiving data from the MPU6050 sensor. 
The flag g$\_$bMPU6050Done is used to indicate when the sensor has been successfully initialized, 
but due to noise, this flag often failed to be set, causing the system to hang indefinitely. 
\begin{code}
/* Commit hash: , main_mpu.c */
g_bMPU6050Done = false;
MPU6050Init(&sMPU6050, &g_sI2CMSimpleInst, 0x68, MPU6050Callback, &sMPU6050);
while (!g_bMPU6050Done) {
    // Waiting for initialization to complete
}
\end{code}\text{}\\
On the above code, the while loop waits for g$\_$bMPU6050Done to turn true. 
However, due to noise, this flag might never be set, leading to a situation where the system appears unresponsive. 
To mitigate this issue, we implemented a delay of 500 ms. This was chosen through binary search. 
A value too low results in unresponsive behavior, while a value too high make the system too sensitive to noise. 
Ultimately, this approach ensures reliable data reception from the MPU6050, balancing responsiveness and stability in the presence of noise.

\section{Conclusion}
To sum up, our last work was to create a working prototype of a laser turret that utilizes a gyroscopic system based off the MPU6050 sensor and the Tiva C LaunchPad. 
This achievement was possible due to the structured sequence of activities which included collecting, 
processing and transmitting data in such a way that the system was able to point a laser at any direction 
accordingly to the movement.
\\\\
Even with problems arising with data consistency, the timing of communications and noise sources, 
we were still able to rectify problems by adopting a more pliable approach to problems during the iterations 
which then greatly increased system performances. The given project increased our level of development in embedded systems, 
while participating as well and working in a team. Overall, the hardware-software integration in mobile systems was a great 
experience for us, and, no doubt, will lay down a solid base for us in similar projects shortly.

\end{document}